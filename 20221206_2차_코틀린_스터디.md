# 02 변수와 자료형, 연산자

## 02-3 자료형 검사하고 변환하기

- 코틀린은 변수를 사용할 떄 반드시 값이 할당되어야 한다는 원칙이 있음
- 값이 없는 상태는 null
- 코틀린에서는 null 상태인 변수를 허용하려면 물음표(?) 기호를 사용해 선언해야 함

### null을 허용한 변수 검사하기

- null을 허용하는 변수를 사용하려면 null을 검사하고 처리하는 방법까지 고려해야 함
- NullPointerException(NPE)
- 코틀린은 변수에 아예 null을 허용하지 않아 이 문제를 미리 방지할 수 ㅇ있음

**변수에 null 할당하기**

```kotlin
val str1 : String = "Hello Kotlin"
str = null // 오류! null을 허용하지 않음
```

- 변수에 null 할당을 허용하려면 자료형 뒤에 물음표(?) 기호를 명시해야 함

```kotlin
val str1 : String? = "Hello Kotlin"
str = null
```

- 변수의 null 허용 여부에 따라 String과 String?이 서로 다른 자료형이라는 것을 이해해야 함

**세이프 콜과 non-null 단정 기호를 활용하여 null을 허용한 변수 사용하기**

- String?형에서는 세이프콜(?.)이나 nun-null 단정 기호(!!.)만 허용한다
- 세이프 콜이란 null이 할당되어 있을 가능서이 있는 변수를 검사하여 안전하게 호출하도록 도와주는 기법
- 세이프콜을 추가하려면 호출할 변수 이름 뒤에 ?.를 작성하면 됨 `${str1?.length}`
- 변수 str1을 검사한 다음 null이 아니면 str1의 멤버 변수인 length에 접근해 값을 읽도록 만든 것
- str1을 검사해보니 아무것도 들어 있지 않으므로 length에 접근하지 않고 그대로 null을 출력
- non-null 단정 기호는 변수에 할당된 값이 null이 아님을 단정하므로 컴파일러가 null 검사 없이 무시
- 변수에 null이 할당되어 있어도 컴파일은 잘 진행되지만 실행 중에 NPE를 발생 `${str1!!.length}`

**조건문을 활용해 null을 허용한 변수 검사하기**

- 조건문으로 null을 허용한 변수를 검사해도 됨
- null을 허용한 변수의 null 상태 가능성을 검사하기만 하면 코틀린 컴파일러는 오류를 발생시키지 않음

```kotlin
if(str1 != null) str1.length else -1
```

- str1 != null을 통해 str1 변수에 할당된 값이 null이 아닌 경우에만 str1.length를 사용하도록 만든 것

**세이프 콜과 엘비스 연산자를 활용해 null을 허용한 변수 더 안전하게 사용하기**

- null을 허용한 변수를 조금 더 안전하게 사용하려면 세이프 콜 ?.과 엘비스 연산자 ?:를 함께 사용
- 엘비스 연산자는 변수가 null인지 아닌지 검사하여 null이 아니라면 왼쪽 식을 그대로 실행하고 null 이라면 오른쪽 식을 실행

```kotlin
${str1?.length ?: -1}
```

- 위의 조건문을 활용한 경우와 동일함
- 세이프 콜과 엘비스 연산자를 사용하면 null인 경우 반환값을 -1과 같은 특정 값으로 대체함으로써 null 발생을 대비할 수 있으므로 안전하고, 코드를 한 줄에 표현할 수 있어 가독성이 좋아짐

### 자료형 비교하고 검사하고 변환하기

- 코틀린의 자료형은 모두 참조형으로 선언
- 컴파일을 거쳐서 최적화될 때 Int, Long, Short 와 같은 자료형은 기본형 자료형으로 변환됨
- 코틀린에서는 자료형이 서로 다른 변수를 비교하거나 연산할 수 없음
- 코틀린에서는 자료형이 서로 다른 변수를 같은 자료형으로 만들어야 연산할 수 있음

**자료형 변환**

- 코틀린에서는 자료형이 다르면 변환 함수를 사용해야 함
- 자바에서는 자료형이 서로 다르면 자동으로 변환됨
- 자바에서는 서로 다른 자료형을 가진 변수를 할당할 때 작은 자료형에서 큰 자료형으로 변환됨. (자동 형 변환)
- 코틀린에서는 자료형이 다른 변수에 재할당하면 자동 형 변환이 되지 않고 자료형 불일치 오류가 발생
- 만일 자료형을 변환해 할당하고 싶다면 코틀린에서는 자료형 변환 메서드를 이용해야 함
- 표현식에서 자료형이 서로 다른 값을 연산하면 자료형이 표현할 수 있는 범위가 큰 자료형으로 자동 형 변환하여 연산
- toByte, toFloat, toLong, toDouble, toShort, toChar, toInt

**기본형과 참조형 자료형의 비교 원리**

- 자료형을 비교할 때는 단순히 값만 비교하는 방법과 참조 주소까지 비교하는 방법이 있음
- 단순히 값만 비교할 때는 이중 등호(==)를 사용하고 참조 주소를 비교하려면 삼중 등호(===)를 사용
- 이중 등호는 참조에 상관 없이 값이 동일하면 true를, 값이 다르면 false를 반환
- 삼중 등호는 값과 상관 없이 참조가 동일하면 true를 반환. 값이 동일하더라도 참조 주소가 다르면 false
- 참조형으로 선언된 a와 b는 코틀린 컴파일러가 기본형으로 변환하여 저장함
- 참조 주소까지 달라지는 경우는 null을 허용한 변수는 같은 값을 저장해도 이중 등호와 삼중 등호를 사용한 결과값이 다름
- Int 형으로 선언된 a는 기본형으로 변환되어 스택에 128이라는 값 자체를 저장
- Int? 형으로 선언된 b는 참조형으로 저장되므로 b에는 128이 저장된 힙의 참조 주소가 저장되어 있음
- 그래서 a와 b를 삼중 등호로 비교하면 false가 나옴

```kotlin
val a: Int = 128
val b = a
println( a === b ) // true

val c: Int? = a
val d: Int? = a
val e: Int? = c
println(c == d) // true
println(c === d) // false
println(c === e) // true
```

![IMG_2804](https://user-images.githubusercontent.com/20595690/208664357-52d2addf-97c0-4c7e-b7db-1dcf46c88b96.png)

- 저장되는 값이 128보다 작으면 그 값은 캐시에 저장되어 참조됨
    - 코틀린에서는 참조형으로 선언한 변수의 값이 -128~127 범위에 있으면 캐시에 그 값을 저장하고 변수는 캐시 주소를 가르켜 더 좋은 성능의 프로그램을 만들 수 있도록 함
    - 위 예제에서 a의 값을 128이 아니라 -128~127 값으로  변경하면 c와 d의 참조 주소 값이 같아져 a, b, c, d 를 삼중 등호로 비교한 값은 모두 true가 됨

**스마트 캐스트 알아보기**

- 어떤 값이 정수일 수도 있고 실수일 수도 있다면 컴파일러가 자동으로 형 변환을 하는 스마트 캐스트를 사용
- 대표적으로 스마트 캐스트가 적용되는 자료형은 Number형
- Number형을 사용하면 숫자를 저장하기 위한 특수한 자료형 객체를 만듬
- Number형으로 정의된 변수에는 저장되는 값에 따라 정수형이나 실수형 등으로 자료형이 변환됨

```kotlin
val test: Number = 12.2
```

**자료형 검사하기**

- 변수의 자료형을 알아내는 방법은 is 키워드를 사용
- 왼쪽 항의 변수가 오른쪽 항의 자료형과 같으면 true, 아니면 false

```kotlin
if (num is Int) {
    print(num)
} else if (num !is Int) { // num이 Int형이 아닐 때, !(num is Int)와 동일
    print("Not a Int")
}
```

- is는 변수의 자료형을 검사한 다음 그 변수를 해당 자료형으로 변환하는 기능
- Any형을 사용하면 자료형을 결정하지 않은 채로 변수를 선언할 수 있음
- Any형은 코틀린의 최상위 기본 클래스로 어떤 자료형이라도 될 수 있음
- is를 사용하여 자료형을 검사하면 검사한 자료형으로 스마트 캐스트 됨

**as에 의한 스마트 캐스트**

- as로 스마트 캐스트도 가능하며, as는 형 변환이 가능하지 않으면 예외를 발생시킴

```kotlin
val x: String = y as String
```

- y가 null이 아니면 String으로 형 변환되어 x에 할당됨
- y가 null이면 형 변환을 할 수 없으므로 예외가 발생
- null 가능성까지 고려하여 예외 발생을 피하려면 물음표(?) 기호를 사용할 수 있음

```kotlin
val x: String? = y as? String

```

**묵시적 변환**

- Any형은 자료형이 특별히 정해지지 않은 경우에 사용
- 코틀린의 Any형은 모든 클래스의 뿌리
- 사용자가 직접 만든 클래스까지 모두 Any형의 자식
- Any는 자바의 최상위 클래스인 Object와 비슷하지만 서로 다른 유형
- Any형은 무엇이든 될 수 있기 때문에 언제든 필요한 자료형으로 자동 변환 가능

```kotlin
val a: Any = 1
a = 20L
println("a: $a type: ${a.javaClass}")
```

- 함수와 판단문을 사용해 언제든지 필요한 자료형에 따른 역할을 지정하여 처리할 수 있음

```kotlin
fun checkArg(x: Any) {
    if (x is String) {
        println("x is String: $x")
    } if (x is Int) {
        println("x is Int: $x")
    }
}
```

- is 연산자를 이용하여 인자로 전달받은 값을 검사하며 자료형을 Any에서 검사한 자료형으로 변환

## 02-4 코틀린 연산자

- 자바의 삼항 연산자는 코틀린에서 사용하지 않음

### 기본 연산자

- 산술, 대입, 증가, 감소, 비교, 논리 연산자 등

**수식의 구조**

- 이때 연산자는 항의 개수에 따라서 단항 연산자(항이 1개), 이항 연산자(항이 2개), 삼항 연산자(항이 3개)로 구분

**산술 연산자**

- 사칙연산에 사용되는 사칙 연산자(+,-,*,/)와 나머지 연산자(%)
- 나머지 연산은 홀수나 짝수 같은 특정 구간의 수를 알아내기에 유용

![IMG_2811](https://user-images.githubusercontent.com/20595690/208664377-d9e7cc8f-30e4-458c-a7a4-c76f87d6ac0d.png)

**대입 연산자**

- 변수에 값을 할당하는 연산자로, 이항 연산자 중 우선순위가 가장 낮음
- 다른 연산자의 연산이 모두 끝나면 그때 대입 연산자가 동작함
- 대입 연산자 오른쪽에는 값이나 값이 있는 변수, 표현식 등을 사용

![IMG_2812](https://user-images.githubusercontent.com/20595690/208664382-63b44cda-fdf3-4978-9c3f-8bcaf5bf7f30.png)

**증가 연산자와 감소 연산자**

- 항이 1개인 단항 연산자
- 항의 앞이나 뒤에 붙여 사용하며 이름 그대로 1을 더하거나 빼는 연산을 수행
- 항 앞에 증가, 감소 연산자를 붙이면 연산을 마친 다음 그 값을 대입
- 항 뒤에 증가, 감소 연산자를 붙이면 먼저 그 값을 대입한 다음 연산을 수행

![IMG_2812 2](https://user-images.githubusercontent.com/20595690/208664390-8f1b72e3-7ecf-4b4d-b4a8-04877ba28500.png)

**비교 연산자**

- 2개 항을 비교하기 위해 사용
- 모든 비교 연산자는 비교 결과가 참이면 true, 거짓이면 false를 반환

![IMG_2813](https://user-images.githubusercontent.com/20595690/208664413-7e0bb5c1-74fe-4fdf-b5a0-69a8a2361485.png)

![IMG_2814](https://user-images.githubusercontent.com/20595690/208664422-db7db080-9cfb-4f36-9552-10aa4cab2634.png)

- 삼중 등호와 부정 이중 등호 연산(===, !==)인 참조 연산자는 자바에는 없지만 코틀린에는 존재

**논리 연산자**

- 논리곱 연산자, 논리합 연산자, 부정 연산자

![IMG_2814 2](https://user-images.githubusercontent.com/20595690/208664429-48823b6e-1761-4160-b1e2-ba537762bee7.png)

- 단축 평가
    - 논리합 연산자(||) 왼쪽의 항이 true이면 코틀린 컴파일러는 오른쪽 항을 아예 평가하지 않음
    - 논리합 연산자는 왼쪽이나 오른쪽 항 중 1개의 항만 true이면 true를 반환하기 때문
    - 논리곱 연산자도 왼쪽 항이 false 이면 오른쪽 항을 평가하지 않고 바로 false를 반환

### 비트 연산자

- 비트 연산자는 기계가 이해할 수 있는 값인 0과 1을 처리하는 데 사용
- 비트 연산자는 프로그래머가 기기를 직접 제어해야 하는 경우 아주 유용
- 비트 연산 중에는 모든 비트를 뒤집는 연산도 있음

**비트 연산을 위한 비트 메서드**

- 메서드처럼 사용해도 되지만 연산자처럼 사용할 수 있음
- shl() 메서드는 4.shl(1) 또는 4 shl 1 과 같은 방법으로 사용할 수 있음
- 4 shl 1 과 같이 멤버에 접근하는 점(.) 연산자와 소괄호를 생략하는 표현식을 중위 표현식이라 함

![IMG_2816](https://user-images.githubusercontent.com/20595690/208664438-8559ecd4-72cd-4504-be46-cdb183c130ad.png)


**비트 이동 연산자 shl, shr**

- 비트를 왼쪽이나 오른쪽으로 밀어낸 다음 사라진 비트의 값은 0으로 채우며 부호 비트는 그대로 둠
- 비트 이동 연산자는 컴퓨터가 쉽게 다룰 수 있는 비트를 이용하여 연산하는 것이기 때문에 연산 속도가 아주 빠름
- 4에 2를 곱하는 것보다 비트 이동 연산자를 이용하여 비트를 왼쪽으로 1칸 밀어내는 것이 더 빠름
- 비트를 왼쪽으로 1칸 밀어내는 것은 2를 곱하는 것으로, 비트를 오른쪽으로 1칸 밀어내는 것은 2로 나누는 것

```kotlin
println(4.shl(1))
println(4 shl 1)
```

- 아주 큰 값에 비트 이동 연산자를 사용할 때는 부호 비트에 주의해야 함
- 부호 비트가 바뀌면 예상하지 못한 결과를 얻을 수 있음
- 2진법, 16진법에도 비트 이동 연산자를 사용할 수 있음

**비트 이동 연산자 ushr**

- 제일 왼쪽 비트에 0을 밀어 넣으면서 오른쪽으로 비트가 이동하기 때문에 부호 비트까지 포함하여 비트를 밀어냄

**논리합 연산자 or**

- 두 수의 비트를 일대일 대응으로 비교하며 비트의 값이 하나라도 1이면 1을 반환

```kotlin
result = number1 or number2
```

**논리곱 연산자 and**

- 두 비트 값을 비교하여 둘 다 1이면 1을 반환

**배타적합 연산자 xor**

- 두 비트 값을 비교하여 같으면 0, 다르면 1을 반환

**반전 연산자 inv**

- 비트를 모두 반대로 뒤집음