
<br>

# 05-4. super와 this의 참조

클래스를 상위와 하위 클래스로 설계하다 보면 때로는 상위와 현재 클래스의 특정 메서드나 프로퍼티, 생성자를 참조해야 하는 경우가 생깁니다. 상위 클래스는 super 키워드로, 현재 클래스는 this 키워드로 참조가 가능합니다. 


![image](https://user-images.githubusercontent.com/101503543/214342865-abffec43-e395-4c6e-a431-a72270bcaa85.png)


<br>
<br>
<br>

## super로 상위 객체 참조하기

super를 사용하면 상위 클래스의 프로퍼티나 메서드, 생성자를 사용할 수 있습니다.

일부는 상위 클래스의 동작을 하고 일부는 현재 클래스에서 새롭게 정의할 수 있습니다. 상위 클래스의 동작을 위해 super 메서드()와 같이 호출할 수 있습니다. 그 외에도 상위 클래스의 프로퍼티를 super.프로퍼티로 참조해 사용하거나 super( )를 사용해 생성자를 호출할 수 있습니다.

<br>
<br>
<br>

## this로 현재 객체 참조하기

- 여러 개의 부 생성자에서 참조하기

현재 객체를 참조하는 키워드는 this를 이용해 프로퍼티, 메서드, 생성자 등을 참조할 수 있습니다.

![image](https://user-images.githubusercontent.com/101503543/214343867-7a383e83-bcd3-4efc-b340-01947514fcf0.png)


상속을 통해서 클래스를 만드는 경우에는 상위 클래스의 생성자가 있다면 반드시 하위 클래스에서 호출해야 합니다. 따라서 생성자 코드를 실행하기 전에 현재 클래스를 가리키는 this나 상위 클래스를 가리키는 super를 사용해 위임하여 다른 생성자를 처리할 수 있게 됩니다.

<br>

- **주 생성자와 부 생성자 함께 사용하기**

만일 주 생성자와 부 생성자가 함께 있다면 this를 사용해 주 생성자를 가리킬 수 있습니다. 

생성하는 객체의 인자 수에 따라 부 생성자 혹은 주 생성자를 호출합니다.

고차 함수에서 배웠듯이 인자에 함수를 지정할 수 있습니다.

![image](https://user-images.githubusercontent.com/101503543/214344760-822bbcc8-0bdb-4d5d-a1f4-ee4ba1997cc1.png)

<br>
<br>
<br>

## 바깥 클래스 호출하기
특정 클래스 안에 선언된 클래스를 이너 클래스(Inner Classs)라고 합니다.

이너 클래스에서 바깥 클래스의 상위 클래스를 호출하려면 super 키워드와 함께 @기호 옆에 바깥 클래스 이름을 작성합니다.

![image](https://user-images.githubusercontent.com/101503543/214345248-25e6f930-d85b-417f-84df-03bdb096413f.png)


c1 객체에 이너 클래스인 Inside( )에 생성자 표기로 접근하고 다시 test ( ) 메서드에도 각각 점(.)으로 접근하고 있습니다.


<br>
<br>
<br>

## 인터페이스에서 참조하기
인터페이스(Interface)는 일종의 구현 약속으로 인터페이스를 참조하는 클래스는 인터페이스가 가지고 있는 내용을 구현해야 하는 가이드를 제시합니다. 따라서 인터페이스 자체로는 객체로 만들 수 없고 항상 인터페이스를 구현하는 클래스에서 생성해야 합니다.

코틀린은 자바처럼 한 번에 2개 이상의 클래스를 상속받는 다중 상속이 되지 않습니다. 하지만 인터페이스로는 필요한 만큼 다수의 인터페이스를 지정해 구현할 수 있습니다. 이때 각 인터페이스의 프로퍼티나 메서드의 이름이 중복될 수 있죠. 만일에 동일한 이름의 프로퍼티나 메서드가 있다면 앵글 브래킷(<>)을 사용해 접근하려는 클래스나 인터페이스의 이름을 정해줍니다.

![image](https://user-images.githubusercontent.com/101503543/214346086-34f0c310-0a0b-4ae6-9208-fb7de24b9d11.png)
![image](https://user-images.githubusercontent.com/101503543/214346205-8ee24506-2dff-40de-8db2-53b168248dee.png)

중복된 이름 앵글 브래킷을 사용해 super\<A>.f( )와 super\<B>.f( )로 구분할 수 있습니다.

<br>
<br>
<br>
<br>

# 05-5. 정보 은닉 캡슐화

클래스를 작성할 때 숨겨야 하는 속성이나 기능이 있을 수 있습니다. 이러한 개념을 캡슐화(Encapsulation)라고 합니다. 이러한 정보 은닉은 객체 지향 프로그래밍의 가장 큰 특징이기도 합니다.

<br>

## 가시성 지시자
각 클래스나 메서드, 프로퍼티의 접근 범위를 가시성(Visibility)이라고 합니다. 각 클래스나 메서드, 프로퍼티에 가시성 지시자(Visibility Modifier)에 의해 공개할 부분과 숨길 부분을 정해 줄 수 있습니다.

- 코틀린의 가시성 지시자는 다음과 같은 것들이 있습니다.  
![image](https://user-images.githubusercontent.com/101503543/214346779-0e1c7f45-a7fa-4104-b6e2-40fb80af3e6b.png)

- 가시성 지시자가 선언되는 위치는 다음과 같습니다.  
![image](https://user-images.githubusercontent.com/101503543/214346917-2643a583-873e-4ece-81a2-374e97e859f8.png)


이들 지시자는 전역 변수, 함수, 클래스, 프로퍼티, 메서드, 인터페이스 등에 붙여서 사용할 수 있습니다. 가시성 지시자를 선언하지 않으면 public이 기본값입니다.
만일 주 생성자 앞에 가시성 지시자를 사용하는 경우는 constructor 키워드를 생략할 수 없습니다.

![image](https://user-images.githubusercontent.com/101503543/214347606-24b4fea9-716a-43ed-ba9f-4eaaa7715606.png)

<br>
<br>

### private

private은 접근 범위가 선언된 요소에 한정하는 가시성 지시자입니다. 예를 들어 클래스를 private과 함께 선언하면 그 클래스 안의 멤버만 접근할 수 있습니다.

![image](https://user-images.githubusercontent.com/101503543/214348369-abb9ec86-104c-45b0-8581-2cdb24f78471.png)
![image](https://user-images.githubusercontent.com/101503543/214348545-64237a9c-d6fd-4e23-9243-f75a9a39bf0f.png)


이 예제에서 PrivateClass 클래스는 private으로 선언되어 있으므로 다른 파일에서 접근할 수 없습니다. 같은 파일에서는 PrivateClass의 객체를 생성할 수 있습니다. 만일 다른 클래스에서 프로퍼티로서 PrivateClass의 객체를 지정하려면 똑같이 private으로 선언해야 합니다.
객체를 생성했다고 하더라도 PrivateClass의 멤버인 i와 privateFunc ( ) 메서드가 private으로 선언되었기 때문에 다른 클래스나 main( ) 같은 최상위 함수에서 접근할 수 없습니다. 
Private 멤버는 해당 클래스 내부에서만 접근이 가능합니다.

<br>
<br>

### protected

protected 지시자는 최상위에서 선언된 요소에는 지정할 수 없고 클래스나 인터페이스와 같은 요소의 멤버에만 지정할 수 있습니다. 멤버가 클래스인 경우에는 protected로 선언할 수 있습니다.
protected로 지정된 멤버는 상속된 하위 클래스에서는 자유롭게 접근이 가능합니다. 다만 외부 클래스나 객체 생성 후 점(.) 표기를 통해 protected 멤버에 접근하는 것을 허용하지 않습니다.

<br>
<br>

### internal
코틀린의 internal은 자바와 다르게 새롭게 정의된 이름입니다. internal은 프로젝트 단위의 모듈(Module)을 가리키기도 합니다. 모듈이 달라지면 접근할 수 없는 거죠. 기존의 자바에서는 package라는 지시자에 의해 패키지 이름이 같은 경우에 접근을 허용했습니다. 코틀린에서는 패키지에 제한하지 않고 하나의 모듈 단위를 대변하는 internal을 씁니다. 만일 프로젝트에 또 다른 모듈이 없어 하나만 있는 경우 internal의 접근 범위는 프로젝트 전체가 됩니다.

<br>

#### **+ 참고 : 자바의 package 지시자**
자바의 가시성 지시자 기본값인 package 지시자는 코틀린에서 사용하지 않습니다. 자바에서 package로 지정된 경우 접근 요소가 패키지 내부에 있다면 접근할 수 있습니다. 하지만 프로젝트 단위 묶음의 .jar 파일이 달라져도 패키지 이름이 동일하면 다른 .jar에서도 접근할 수 있었기 때문에 보안 문제가 발생할 수 있었습니다. 코틀린에서는 이것을 막고자 기존의 package를 버리고 internal로 프로젝트의 같은 모듈(빌드된 하나의 묶음)이 아니면 외부에서 접근할 수 없게 했습니다. 이것은 모듈이 다른 .jar 파일에서는 internal로 선언된 요소에 접근할 수 없다는 뜻입니다.

![image](https://user-images.githubusercontent.com/101503543/214350232-56e75987-1a93-4323-bf10-b9d4578e9cf2.png)


이제 같은 프로젝트의 모듈에만 있으면 어디서든 접근이 가능합니다. 파일이 달라져도 동일한 모듈에 있다면 바로 접근할 수 있습니다.

<br>
<br>
<br>

## 가시정 지시자와 클래스의 관계

가시성 지시자는 클래스 간의 관계에서도 접근 범위를 정할 수 있기 때문에 상속된 하위 클래스에서 가시성 지시자를 사용하거나 다른 클래스와의 연관 관계를 지정하기 위해서도 사용할 수 있습니다.

UML의 가시성 표기 기호

- \- : private
- \+ : public
- \# : protected
- ~ : package

UML 다이어그램으로 가시성에 대한 변수 접근성을 확인해 봅시다.

<p align = center><img src = https://user-images.githubusercontent.com/101503543/214514793-473f4baa-c2ec-4542-8026-b55b1d0d9c80.png></p>


다이아몬드 화살표는 Base 클래스 내부에 Nested 클래스가 구성되어 있음을 나타내고 있습니다.

흰색 머리의 화살표는 상속을 나타내고, 일반 화살표는 클래스를 멤버로 가진 경우를 나타냅니다.

다이어그램을 통해서 프로퍼티의 가시성과 클래스의 연관 관계를 명확히 파악할 수 있습니다.

가시성 지시자에 따라 접근할 수 있는 범위가 달라짐을 알 수 있습니다.

만일 오버라이딩된 멤버가 있는 경우에는 상위 클래스와 동일한 가시성 지시자를 갖습니다.

<br>
<br>
<br>
<br>

# 05-6. 클래스와 클래스의 관계

<br>

## 클래스 혹은 객체 간의 관계

클래스들이나 객체들 간의 관계는 약하게 연결된 관계부터 강하게 결합된 관계가 있습니다.

<br>

- 먼저 약하게 참조되고 있는 관계로 연관(Association)이나 의존(Dependency) 관계가 있습니다. 이런 관계에서는 보통 소유의 개념 없이 어떤 객체에서 또 다른 객체를 ‘이용한다’라고 할 수 있습니다.  
<br>서로 이용하지만 한쪽이 다른 쪽을 소유하는 관계는 아닌 것이죠. 서로의 생명주기(Life-cycle)도 다릅니다. 참조가 없는 단순한 연관 관계고, 참조 상태인 경우 의존 관계가 됩니다.

<br>

- 다이어그램에서 연관 관계는 실선으로 표기하고 의존 관계에 있을 때는 점선 화살표를 사용합니다. 여러 요소를 담을 수 있는 컨테이너 자료형에 해당하는 경우에는 포함 관계를 위한 개수를 적어줍니다. 제로(0), 하나(0..1) 혹은 다수(0..*)의 객체와 연관을 가질 수 있다는 것을 나타내기 위한 표기법을 사용하기도 합니다.

<br>

- 예) 연못에 오리가 한 마리도 없을 경우도 있으니 개수 관계는 0..*로 표기할 수 있습니다. 따라서 연못과 오리는 집합(Aggregation)관계라고 합니다.  
<br>
하지만 연못과 오리는 서로 따로 떨어져도 문제가 없습니다. 별도로 서로 따로 존재하는 경우 흰색 다이아몬드 모양의 표기법으로 나타냅니다.

<br>

- 마지막으로 합성 혹은 구성(Composition) 관계에 있는 경우 두 개체가 아주 밀접하게 관련되어 있어 독립적으로 존재하기 힘든 것을 말합니다.  
<br>
두 개체 간의 생명주기는 의존되어 있습니다. 이런 구성 관계는 검정 다이아몬드로 표기합니다.

<br>
<br>
<br>

### 클래스 간의 관계를 판별하는 방법

- ‘연관, 의존, 집합, 구성’과 같은 관계가 있습니다.

- 클래스 간의 관계는 두 클래스가 서로 참조하느냐 아니냐에 따라 나뉘고, 그런 다음 두 클래스가 생명주기에 영향을 주는지에 따라 나뉠 수 있습니다.

- 객체는 서로 독립적으로 존재할 수 있으며 서로 참조를 유지하면 연관 관계입니다. 참조를 유지하지 않으면 연관보다 약한 의존 관계가 됩니다.  
포함 관계에 있지만 객체의 생명주기가 서로 유지되고 있는 경우에는 집합 관계가 되며, 포함 관계의 객체가 사라질 때 같이 사라져 생명주기가 유지되지 않으면 구성 관계입니다. 

<p align = center><img src=https://user-images.githubusercontent.com/101503543/214516632-8d0d11f4-0a06-454c-b526-583a20967b6c.png>
</p>


<br>
<br>
<br>

### 연관 관계

연관(Association) 관계란 2개의 서로 분리된 클래스가 연결을 가지는 것입니다. 단방향 혹은 양방향으로 연결될 수 있습니다. 핵심은 두 요소가 서로 다른 생명주기를 가지고 있다는 점입니다.

<p align =center><img src = https://user-images.githubusercontent.com/101503543/214601516-b6c4b293-0bf4-463e-ba31-cf04c2d8a5d9.png width=80%>
</p>


예를 들어 Doctor와 Patien 클래스의 객체는 따로 생성되며 서로 독립적인 생명주기를 가지고 있습니다. 이 코드에서는 두 클래스가 서로의 객체를 참조하고 있으므로 양방향 참조를 가집니다. 단방향이든 양방향이든 각각의 객체의 생명주기에 영향을 주지 않을 때는 연관 관계라고 합니다.

<br>

### 의존 관계

한 클래스가 다른 클래스에 의존되어 있어 영향을 주는 경우 의존(Dependency) 관계라고 합니다.

<br>

### 집합 관계

연관 관계와 동일하지만 특정 객체를 소유한다는 개념이 추가된 것입니다.

2개의 개체는 따로 생성되어 서로의 생명주기에 영향을 주지는 않습니다.

<br>

### 구성 관계
구성(Composition) 집합 관계와 거의 동일하지만 특정 클래스가 어느 한 클래스의 부분이 되는 것입니다. 구성품으로 지정된 클래스는 생명주기가 소유자 클래스에 의존되어 있습니다. 만일 소유자 클래스가 삭제되면 구성하고 있던 클래스도 같이 삭제됩니다.

관계에 따라 클래스를 정의하면 현실 세계의 문제를 쉽게 프로그래밍으로 풀어낼 수 있습니다.

<br>
<br>

## 객체 간의 메시지 전달하기
두 객체 간의 메시지 전달(Message Sending)은 프로그래밍에서 아주 흔하며 시간의 흐름에 따라 일어나는 경우가 대부분이기 때문에 주로 UML의 시퀀스 다이어그램(Sequence Diagram)으로 표현합니다.

![image](https://user-images.githubusercontent.com/101503543/214602799-c9eebdcf-04f9-4440-9e99-8000542c041b.png)


앞의 시퀀스 다이어그램은 클래스로부터 만들어진 3개의 객체로 볼 수 있습니다.
세로 점선은 시간의 흐름을 나타냅니다. 각 화살표는 주고 받을 메시지이며 반환되어 돌아올 때는 점선으로 표기합니다.

보통 메시지는 받는 수신자와 실행할 메서드가 사용됩니다. 메서드에는 매개변수로 원하는 메시지를 보낼 수 있습니다.





