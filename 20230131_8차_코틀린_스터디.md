# 06 프로퍼티와 초기화
## 06-1 프로퍼티의 접근
- 코틀린에서는 클래스 내에 선언한 변수를 '프로퍼티'라고 함. 자바에서는 '필드'라고 부름
- 자바의 필드는 단순한 변수 선언 부분만을 가지기 때문에 접근하기 위한 메서드를 일일이 만들어 두어야 함
- 코틀린에서는 변수 선언 부분과 기본적인 접근 메서드를 모두 가지고 있기 때문에 프로퍼티라는 새로운 이름으로 부르는 것
### 자바에서 필드를 사용할 때 문제점
- 접근 메서드의 2가지 형태인 게터와 세터를 만드는 것
- 자바에서는 각 필드를 읽어 들이기 위해 게터를 만들고 값을 할당하기 위해 세터를 직접 만들어 줘야 함
- 게터와 세터가 있으면 각 필드는 외부에서 직접 접근할 수 없게 되고 필요한 경우에만 게터와 세터를 통해서만 값을 읽거나 지정할 수 있음
- 다양한 개체가 필드에 직접 접근하게 하면 데이터의 무결성이 깨질 수 있고 보안상 문제도 있기 때문에 이런 접근 메서드를 사용
- 자바의 게터는 반환값의 자료형이 참조할 멤버 필드의 자료형과 일치해야 함
- 세터의 반환 자료형은 보통 void이지만 설정 결과를 알려줄 수 있는 자료형을 설정할 수 있음
- 각 세터의 매개변수도 멤버 필드와 동일한 자료형이어야 함
- 자바의 필드가 점점 늘어나면 그와 상응하는 접근 메서드도 아주 많아지게 되어 코드가 읽기 어렵게 됨
- 코틀린에서는 각 프로퍼티에 게터와 세터가 자동으로 만들어짐
### 코틀린에서 게터와 세터가 작동하는 방식
- 프로퍼티에 직접 접근하는 것처럼 보이나 코틀린 내부적으로 접근 메서드가 내장되어 있음
- getName()과 같은 코틀린 내부의 게터 메서드를 통해 접근하는 것
- 프로퍼티에 값을 할당하면 같은 세터 메서드를 사용하는 것
```java
public final class User {
    private final int id;

    public final int getId() {// id는 val 로 되어 있어 읽기 전용이므로 getId()만 생성되어 있음
        return this.id;
    }
}
```
코틀린에서는 별도로 게터와 세터를 지정하지 않았지만, 자바로 변환된 코드를 보면 프로퍼티에 대한 게터와 세터 접근 메서드가 자동으로 만들어져, 해당 프로퍼티에 접근할 때 이용되는 것을 알 수 있음
### 기본 게터와 세터 직접 지정하기
- 게터와 세터가 포함되는 프로퍼티 선언 구조
```text
var 프로퍼티 이름[: 프로퍼티 자료형] [= 프로퍼티 초기화]
    [get( ) { 게터 본문 }]
    [set(value) { 세터 본문}]
val 프로퍼티 이름[: 프로퍼티 자료형] [= 프로퍼티 초기화]
    [get( ) { 게터 본문 }]
```
- 프로퍼티를 var로 선언하는 경우에는 게터와 세터 둘 다로 선언할 수 있지만, val로 선언하는 경우에는 게터만 가능
- 각 프로퍼티의 들여쓰기 위치에 get() 과 set()을 사용해 게터와 세터를 지정
- get()과 set()에 특수한 변수 field와 value
- 이 변수는 게터와 세터에 사용
- value와 field용도
    - value: 세터의 매개변수로 외부로부터 값을 가져옴
    - field: 프로퍼티를 참조하는 변수
- value라는 이름은 정해진 이름은 아니므로 다른 이름으로 변경해 사용할 수 있음
- field는 이름이 정해져 있어 변경할 수 없음

**보조 필드의 역할**
- field는 프로퍼티를 참조하는 변수로 보조필드 라고 함
- get() = field는 결국 각 프로퍼티의 값을 읽는 특별한 식별자
- 게터와 세터 안에서 field대신에 get() = age와 같이 사용하면 프로퍼티의 get() 이 다시 호출되는 것과 같으므로 무한 재귀 호출에 빠져 스택오버플로 오류가 발생할 수 있음
- 그래서 임시적인 보조 필드를 따로 사용해 프로퍼티 변수에 접근
- set()에도 값을 할당하기 위해 프로퍼티 이름을 직접 사용하지 않도록 주의해야 함

### 커스텀 게터와 세터의 사용
- 사용자가 직접 게터와 세터를 정의하면서 새로운 내용을 작성하는 것을 커스텀 게터와 세터라고 함
- 특정 연산을 수행해야 한다면 게터와 세터를 확장해 코드를 구성할 수 있어 편리함
```kotlin
class User(_id: Int, _name: String, _age: Int) {
    val id: Int = _id
    var name: String = _name
        set(value) {
            println("The name was changed")
            field = value.toUpperCase()
        }
    val age: Int = _age
}
```
- set 앞에 private과 같은 가시성 지시자를 넣어주면 외부에서 프로퍼티에 값을 할당할 수 없음
- 외부에서 객체 생성 후 재할당하는 것이 금지됨

**보조 프로퍼티의 사용**
- 보조 필드를 사용하지 않는 경우에는 임시적으로 사용할 프로퍼티를 선언해 놓고 게터나 세터에 사용할 수 있음
```kotlin
class User(_id: Int, _name: String, _age: Int) {
    val id: Int = _id
    private var tempName: String? = null
    var name: String = _name
        get() {
            if (tempName == null) tempName = "NONAME"
            return tempName ?: throw AssertionError("Asserted by othes")
        }
    val age: Int = _age
}
```
- 보조 필드인 field를 사용하지 않고 추가로 내부의 프로퍼티를 임시로 선언해 사용할 수 있음

**프로퍼티의 오버라이딩**
- 프로퍼티는 기본적으로 오버라이딩할 수 없는 final 형태로 선언됨
- 만일 프로퍼티를 오버라이딩 가능하게 하려면 open 키워드를 사용해 프로퍼티를 선언해야 함
- 오버라이딩 시 상위 클래스에 프로퍼티를 val로 정의한 경우에는 하위 클래스에서 var로 변경할 수 있음
- 반대로 var를 val로 변경할 수 없음

## 06-2 지연 초기화와 위임
- 프로퍼티를 선언하면 기본적으로 모두 초기화해야 함
- 객체의 정보가 나중에 나타나는 경우 객체 생성과 동시에 초기화하기 함든 경우 지연 초기화를 사용
- 보통 클래스에서는 기본적으로 선언하는 프로퍼티 자료형들은 null을 가질 수 없기 때문에 생성자에서 초기화하거나 매개변수로부터 값을 초기화해야 하는 것이 규칙
- 지연 초기화lateinit과 lazy 키워드를 통해 이를 사용할 수 있음

### lateinit을 사용한 지연 초기화
- 기본 자료형들은 생성자에서 반드시 초기화되어야 하지만 의존성이 있는 초기화나 유닛 테스트를 위한 코드를 작성하ㅕㄴ서 설정에 의한 초기화를 할 떄는 매번 초기화하기가 불편함
- 해당 자료형의 프로퍼티를 즉시 사용하지 않는데도 미리 생성해서 초기화한다면 메모리가 사용되어 낭비될 수 있음
- 모듈별로 소스코드를 테스트하는 유닛 테스트를 할 때는 임시적으로 객체를 생성시켜야 하는 경우 가많음 (이떄도 지연 초기화 사용)

**프로퍼티 지연 초기화하기**
- 클래스를 선언할 때 프로퍼티 선언은 null을 허용하지 않음
- 지연 초기화를 위한 lateinit 키워드를 사용하면 ㅡㅍ로퍼티에 값이 바로 할당되지 않아도 컴파일러에서 허용하게 됨
- 실행할 때까지 값이 비어 있는 상태면 오류를 유발할 수 있음
- 프로퍼티를 초기화하는 방법은 지금까지 배운 주 생성자에서 초기화, init 블록 초기화, 부생성자 초기화, 매개변수의 기본값 초기화 등을 사용할 수 있음
- init 블록을 통한 초기화
    ```kotlin
    class Person {
        var name: String
        init {
            name = "NONAME"
        }
    }
    ```
- 프로퍼티 name에 할당 연산자를 사용해 기본값을 넣어 초기화
    ```kotlin
    class Person {
        var name: String = "NONAME"
    }
    ```
- lateinit의 제한
    - var로 선언된 프로퍼티만 가능
    - 프로퍼티에 대한 게터와 세터를 사용할 수 없다
- latinit의 사용
  ```kotlin
  class Person {
      lateinit var name: String // 1. 지연 초기화를 위한 선언
      
      fun test() {
          if(!::name.isInitialized) { // 2. 프로퍼티의 초기화 여부 판단
              println("not initialized")
          }
      }
      
      fun main() {
          val kildong = Person()
          kildong.name = "Kildong" // 3. 이 시점에서 초기화됨 (지연 초기화)
      }
  }
  ```
  - 2번의 isInitalized는 프로퍼티가 초기화되었는지 검사하는 코틀린 표준 함수의 API
  - 프로퍼티 참조를 위해 콜론 2개(::)를 사용
  - isInitalized가 true를 반환하면 프로퍼티가 할당되었다는 뜻
- 컴파일러에서는 예외 오류를 감지하지 않기 때문에 값 할당을 잊으면 안됨

**객체 지연 초기화하기**
- 생성자를 통해 객체를 생성할 때도 lateinit을 사용해 필요한 시점에 객체를 지연 초기화할 수 있음
```kotlin
lateinit var person: Person

fun main() {
    person1 = Person("Kildong", 30)
}
```

### lazy를 사용한 지연 초기화
- lateinit을 통해서 프로퍼티나 객체를 선언할 때는 val은 허용하지 않고 var로 선언해야 함
- var로 선언하면 객체나 프로퍼티의 경우 언제든 값이 변경될 수 있음
- 읽기 전용의 val로 선언한 객체나 프로퍼티를 나중에 초기화하려면 lazy를 적용
- lazy의 특징
  - 호출 시점에 by lazy 정의에 의해 블록 부분의 초기화를 진행
  - 불변의 변수 선언인 val에서만 사용 가능
  - val이므로 값을 다시 변경할 수없음

**프로퍼티 지연 초기화하기**
- lazy는 람다식으로 구성되어 lazy 인스턴스 반환값을 가지는 함수
```kotlin
class LazyTest {
    val subject by lazy {
        println("lazy initialized")
      "Kotlin Programming"
    }
  
    fun flow() {
        println("not initalized")
        println("subject one: $subject")
        println("subject two: $subject")
    }
}
```
- by는 프로퍼티를 위임할 때 사용하는 키워드
- 람다식의 맨 마지막 문장이 반환값이 되어 초기화됨

**객체 지연 초기화하기**
- 객체에 대한 lazy 지연 초기화하기
```kotlin
fun main() {
    val person: Person by lazy {
        isPersonInstantiated = true
      Person("Kim", 23) // 이 부분이 Lazy 객체로 반환됨
    }
  
    val personDelegete = lazy { Person("Hong", 40) }
}
```
- lazy만 사용해 위임 변수를 받아서 지연 초기화에 사용
- 객체의 프로퍼티나 메서드가 접근되는 시점에서 초기화됨
- 객체에 lazy가 선언된 시점에 객체가 생성되는 것이 아니라 코드의 접근 시점에서 초기화됨
- by lazy나 lazy 할당의 차이점
    - by lazy: 객체의 위임
    - lazy: 변수에 위임된 Lazy 객체 자체를 나타냄
- 이 변수의 value를 한단계 더 거쳐 객체의 멤버인 value.name과 같은 형태로 접근해야 함

**lazy 모드 확인하기**
- JVM에서 사용하는 lazy의 선언부
- lazy()는 매개변수 없는 람다식을 받을 수 있으며 Lazy<T> 를 반
- lazy 모드
    - STNCHRONIZED: lock 을 사용해 단일 스레드만이 사용하는 것을 보장
    - PUBLICATION: 여러 군데에서 호출될 수있으나 처음 초기화된 후 반환값을 사용
    - NONE: lock을 사용하지 않기 때문에 빠르지만 다중 스레드가 접근 할 수 있다
- by laze(모드 이름) { ... } 형태로 사용할 수 있음
- 항상 단일 스레드에서 사용하고 있다는 것이 보장되면 LazyThreadSafetyMode.NONE을 사용해도 좋음
- 따로 동기화 기법을 사용하지 않는 다면 다른 모드는 사용하는 것을 권장하지 않음
- 단일 스레드 사용의 보장이란?
    - 단 하나의 코드 흐름에서 해당 데이터를 접근하기 때문에 다른 코드에 의해 변경되지 않을 것임을 보장한다는 말
    - 보통 프로그램은 다양한 루틴에 의해 수행되고 여러 개의 스레드가 동시에 수행되는 경우가 많기 때문에 특정 자원 사용할 때 다른 스레드에 의해 값이 변경될 수 있음
    - 이것을 보호하기 위해 동기화된 기법인 lock을 사용하는 synchronized() { ... } 블록을 사용

### by를 이용한 위임
- 코틀린에서도 특정 클래스를 확장하거나 이용할 수 있도록 by를 통한 위임이 가능
- by를 사용하면 하나의 클래스가 다른 클래스에 위임하도록 선언하여 위임된 클래스가 가지는 멤버를 참조 없이 호출할 수 있게 됨
- 프로퍼티 위임이란 프로퍼티의 게터와 세터를 특정 객체에 위임하고 그 객체가 값을 읽거나 쓸 때 수행하도록 만드는 것
- 프로퍼티 위임을 하려면 위임을 받을 객체에 by 키워드를 사용하면 됨
```text
< val|var|class > 프로퍼티 혹은 클래스 이름: 자료형 by 위임자
```

**클래스의 위임**
```kotlin
val cat = Cat()
class Roboy : Animal by cat //Animal의 정의된 Cat의 모든 멤버를 Robot에 위임
```
- 코틀린이 가지고 있는 표준 라이브러리는 open으로 정의되지 않은 클래스를 사용하고 있는데 모두 final 형태의 클래스이므로 상속이나 직접 클래스의 기능 확장이 어렵게 됨
- 이렇게 만들어 둠으로써 표준 라이브러리의 무분별한 상속에 따른 복잡한 문제를 방지할 수 있음
- 필요한 경우에만 위임을 통해 상속과 비슷하게 해당 클래스의 모든 기능을 사용하면서 동시에 기능을 추가 확장 구현할 수 있

**프로퍼티 위임과 by lazy**
- 프로퍼티의 lazy도 by laze { ... } 처럼 by가 사용되어 위임
- lazy는 사실 람다식
- 프로퍼티는 람다식에 전달되어 사용됨
- by lazy에 의한 지연 초기화는 스레드에 좀 더 안정적으로 프로퍼티를 사용할 수 있음
- 프로그램 시작 시 큰 객체가 있다면 초기화할 때 모든 내용을 시작 시간에 할당해야 하므로 느려질 수밖에 없음
- 필요에 따라 해당 객체를 접근하는 시점에서 초기화하면 시작할 때마다 프로퍼티를 생성하느라 소비되는 시간을 줄일 수 있음
