# 07 다양한 클래스와 인터페이스
- 추상클래스는 일종의 설계도 역할
- 데이터클래스는 각 개체들이 주고받는 데이터를 구조화할 수 있음
- 중첩 클래스, 이너 클래스, 실드 클래스, 열거형 클래스 등

## 07-1 추상클래스와 인터페이스
- 추상 클래스는 선언 등의 대략적인 설계 명세와 공통의 기능을 구현한 클래스
- 구체적이지 않은 것
- 추상 클래스를 상속하는 하위 클래스에서 추상 클래스의 내용을 더 구체화해야 함
- 인터페이스도 대략적인 설계 명세를 가지고 몇 가지 기본적인 부분은 구현할 수 있지만 하위에서 더 자세히 구현해야 하는 점은 추상 클래스와 동일
- 인터페이스에서는 프로퍼티에 상태 정보를 저장할 수 없음
- 다중 상속과 같이 여러 개의 인터페이스를 하나의 클래스에 구현하는 것이 가능

### 추상 클래스
- abstract 라는 키워드와 함께 선언하며 추상 클래스로부터 일반적인 객체를 생성하는 방법으로 인스턴수화될 수 없음
- 추상 클래스를 상속하는 하위 클래스가 어떻게 만들어야 하는지를 나타내는 용도로 사용됨

**추상 클래스의 정의와 구현
```kotlin
abstract class Vehicle
```
- 추상 클래스를 설계할 때는 멤버인 프로퍼티나 메서드도 abstract로 선언될 수 있음
- 추상 프로퍼티나 추상 메서드
- 기본적인 프로퍼티나 메서드의 선언은 abstract가 아니므로 특정 초기화나 구현이 필요하지만 abstract로 선언된 프로퍼티나 메서드는 아직 미완성되었다는 의미
- 클래스에서 추상 프로퍼티나 메서드가 하나라도 있다면 해당 클래스는 추상 클래스가 되어야 함
- 추상 클래스는 객체를 생성할 수 없고 기본 설계 역할을 함
- 추상 멤버이기 때문에 하위 클래스에서 재정의하거나 구현해야 함
- 클래스를 상속하려면 open 키워드로 정의되어야 함
- 추상 클래스에서는 상속을 위해 open 키워드를 사용할 필요가 없음
- 추상 프로퍼티나 메서드에도 open이 필요 없음
- 추상 클래스에서는 abstract 키워드 자체가 상속과 오버라이딩을 허용하고 있기 때문
- 일반 프로퍼티나 메서드를 오버라이딩 하려면 open 키워드가 필
- 추상 클래스는 abstract 키워드를 사용해 하위 클래스에서 반드시 갖춰야하는 프로퍼티와 메서드를 제시
- 추상 클래스에는 일반 프로퍼티나 메서드도 만들 수 있기 때문에 공통의 프로퍼티와 메서드를 미리 만들어 둘 수 있음
- 연관성이 높은 클래스의 기능이나 속성을 미리 정의해 둠
- 추상 클래스로부터 하위 클래스를 생성하지 않고 단일 인스턴스로 객체를 생성하려면 object를 사용해서 지정할 수 있음
- 콜론(:) 오른쪽에 생성자 이름을 사용하고 블록에서 관련 메서드를 오버라이딩해 구현해 두어야 함

```kotlin
abstract class Printer {
    abstract fun print()
}

val myPrinter = object: Printer() {
    override fun print() {
        pritnln("출력합니다")
    }
}
```

### 인터페이스
- 인터페이스에서는 abstract로 정의된 추상 메서드나 일반 메서드가 포함됨
- 메서드에 구현 내용이 포함될 수 있음
- 추상 클래스처럼 프로퍼티를 통해 상태를 저장할 수 없고 선언만 할 수 있음
- 객체를 생성할 수 없고 하위 클래스를 통해 구현 및 생성해야 함
- 인터페이스는 현실 세계의 계약서와 비슷함
- 계약서 자체로는 실행되지 않음. 작업자에 의해 구체적인 작업이 구현되어야 실행되는것.
- 기본 설계도 라고 할 수 있음
- 인터페이스를 쓰는 이유는 추상 클래스를 쓸 때의 제한을 생각해보면 추상 클래스도 기본적으로 클래스이기 때문에 상속을 통해 하위 클래스로 확장해 나갈 수 있음
- 하위 클래스는 상속을 하나만 허용하기 때문에 2개 이상의 클래스로부터 프로퍼티나 메서드를 상속받을 수 없다는 단점이 있음
- 상위 클래스와 하위 클래스에 대한 강한 연관이 생기면서 하위 클래스는 상위 클래스의 영향을 받음
- 상위 클래스가 수정되었을때 하위 클래스를 일일이 확인하기 어려운 경우에 부작용을 발생시킬 수 있다는 단점
- 인터페이스는 클래스가 아님. 따라서 상속이라는 형태로 하위 클래스에 프로퍼티와 메서드를 전하지 않음
- 하위 클래스보다는 구현 클래스라고 이야기함
- 구현 클래스의 목적은 인터페이스가 제시한 메서드를 구체적으로 '구현'한다는데 있음
- 인터페이스는 구현 클래스와 강한 연관을가지지 않음. 상속은 하나만 허용했으나 인터페이스는 원하는 만큼 구현 클래스에 붙여서 필요한 메서드를 구현해 내면 됨
- 인터페이스가 바뀐다고 할지라도 그것을 구현하는 클래스에 크게 영향을 끼치지 않게 할 수 있음
- 자바의 인터페이스
    - 코틀린의 인터페이스는 메서드에 구현 내용을 넣을 수 있으나 자바8 이전 버전에는 인터페이스 메서드를 구현할 수 없었음
    - 자바 8부터 인터패이스에 구현 기능을 추가했는데 default 키워드를 통해 구현 내용을 넣을 수 있음
    - 자바에서 기본 메서드(Default Method) 기능을 추가한 가장 큰 이유는 인터페이스를 여러 클래스가 사용하는 경우에 필요한 메서드를 모두 구현해야 하기 떄문
    - 코틀린은 이것을 기본적으로 제공하므로 default 키워드가 필요없음

**인터페이스의 선언과 구현**
- 인터페이스는 interface 키워드를 사용해 선언하고 상속한 하위 클래스에서는 override를 사용해 해당 메서드를 구현해 주어야함
```kotlin
interface 인터페이스 이름 [: 인터페이스이름...] { 
    추상 프로퍼티 선언
    추상 메서드 선언
    [일반 메서드 선언 { ... }] }
```

- 인터페이스 본문에서 메서드는 추상 혹은 일반 메서드 모두 선언이 가능하지만 프로퍼티는 오직 추상 메서드로만 선언해야 함
- abstract 키워드가 없어도 기본은 추상 프로퍼티, 추상 메소드
- 일반 메서드: 구현부를 포함하면 일반적인 메서드로 기본이 됨
- 메서드에는 기본 구현부가 있으면 일반 메서드로서 기본 구현을 가짐
- 상태를 저장할 수 없기에 프로퍼티에는 기본값을 가질 수 없음
```kotlin
class Cat(override var category: String) : Pet { 
    override fun feeding( ) {
        println("Feed thecat atunacan!") 
    }
}

fun main( ) {
    val obj = Cat ("small")
    println("Pet Category: ${obj .category}") 
    obj.feeding( ) // 구현된 메서드
    obj.patting( ) // 기본 메서드
}
```

- 추상 프로퍼티나 추상 메서드였던 부분을 override 키워드를 사용해 구현
- 인터페이스의 구현은 클래스에서 상속을 나타내는 콜론(:)을 동일하게 사용해 정의
- 자바와 코틀린의 상속과 구현
    - 자바에서는 상속은 extends, 구현은 implements로 키워드를 구별하고 있지만 코틀린에서는 둘 다 콜론(:)을 통해서 정의

**게터를 구현한 프로퍼티**
- val로 선언된 프로퍼티는 게터를 통해 필요한 내용을 구현할 수 있음
```kotlin
interface Pet {
    var category: String
    val msgTags: String // val 선언 시 게터의 구현이 가능
        get( ) = ''I' myour lovel y pet !"
}
```

- val로 선언된 msgTags는 초기화할 수 없지만 게터를 통해 반환값을 지정할 수 있음
- 하지만 여전히 보조 필드인 field를 사용할 수 없음
- var로 프로퍼티를 선언하더라도 보조 필드를 사용할 수 없기 때문에 받은 value를 저장할 수 없음

**인터페이스 구현의 필요성**
```kotlin
open class Animal(val name: String)
```
- 메서드를 매번 작성해야하는 이 문제를 인터페이스를 사용할 수 있음
```kotlin
interface Pet {
    var category: String
    val msgTags: String
        get() = '' I ' myour lovelypet!"

    var species: String // 종을 위한 프로퍼티
}

class Cat(name:String, override var category: String) : Pet, Animal(name) { 
    override var species: String="cat" // 프로퍼티를 오버라이딩해 종을 특정 
}
```
- 의존적인 클래스였으나 인터페이스를 이용해서 의존성을 제거
- 독립성을 확보할 수 있다는점에서 인터페이스가 핵심 역할

### 여러 인터페이스의 구현
- 클래스를 통해 다중 상속을 할 수 없음
- 인터페이스를 사용하면 여러 인터페이스로부터 구현할 수 있음
```kotlin
class Pegasus: Bird, Horse { 
    override val wings: Int = 2
    override val maxSpeed: Int = 100 
    override fun fly( ) {
        println("Fly!") 
    }
    override fun run( ) { 
        println("Run!")
    }
    override fun jump( ) {
        super<Horse>.jump( )
        println("Pegasus Jump!") 
    }
}
```
- 인터페이스의 기본 동작을 실행하려 할 때, 만일 이름이 동일한경우 super<인터페이스 이름>.메서드 이름( ) 형태로 구분할 수 있음

### 인터페이스의 위임
- 인터페이스에서도 by 위임자를 사용할 수 있음
- 각각 a와 b를 인터페이스 A와 B에 위임함으로서 해당 메서드를 사용할 때 점(.) 표기법 접근 없이 사용

**위임을 이용한 멤버 접근**
```kotlin
// 1. 각 매개변수에 해당 인터페이스를 위임
class Person(name:Nameable, work: Runnable): Nameable by name, Runnable by work

fun main( ) {
    val person = Person(StaffName(), Work( )) // 2. 생성자를 사용해 객체 바로 전달
    println(person.name)// 2. 여기서 StaffName 클래스의 name접근
    person.run( ) // 3. 여기서 Work클래스의 run접근
}
```
- 각 매개변수에 해당 인터페이스를 위임
- 상속과 같은 형태로 위임을 사용